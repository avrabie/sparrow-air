# Lessons Learned: 



## Spring Data R2DBC and Manual IDs
When implementing a POST request endpoint for creating new Airport entities, we encountered an issue where Spring Data R2DBC's `ReactiveCrudRepository.save()` method was performing an update operation instead of an insert. This happened because we were using a manually set ID (`icaoCode`) as the primary key for our Airport entity.

```java
@Table(name = "airport2s")
public class Airport {
    @Id
    @Column(value = "icao_code")
    private String icaoCode; // ICAO 4-letter code (e.g., "KLAX")
    
    // Other fields...
}
```

### How R2DBC Handles IDs

After investigating with the help of AI, we discovered that Spring Data R2DBC has a specific behavior when dealing with entities that have manually set IDs:

1. When an entity has a non-null ID value, R2DBC assumes the entity already exists in the database
2. As a result, it attempts to perform an update operation instead of an insert
3. This differs from JPA, which uses the `@GeneratedValue` annotation to distinguish between new and existing entities

Spring Data R2DBC makes this assumption because it's designed primarily for scenarios where:
- IDs are auto-generated by the database (using sequences, auto-increment, etc.)
- Or the application explicitly distinguishes between insert and update operations

### The Solution

To solve this issue, we implemented a custom insert method in our repository interface:

```java
@Repository
public interface AirportRepository extends ReactiveCrudRepository<Airport, String> {
    @Query("INSERT INTO airport2s (icao_code, name, city, country, timezone, latitude, longitude) " +
           "VALUES (:#{#airport2.icaoCode}, :#{#airport2.name}, :#{#airport2.city}, :#{#airport2.country}, " +
           ":#{#airport2.timezone}, :#{#airport2.latitude}, :#{#airport2.longitude}) RETURNING *")
    Mono<Airport> insert(Airport airport2);
}
```

Then, in our handler, we used this custom method for creating new airport2s:

```java
public Mono<ServerResponse> createAirport(ServerRequest request) {
    return request.bodyToMono(Airport.class)
            .flatMap(airportRepository::insert)  // Using custom insert method
            .flatMap(airport2 -> ServerResponse
                    .status(HttpStatus.CREATED)
                    .contentType(APPLICATION_JSON)
                    .bodyValue(airport2))
            .onErrorResume(e -> ServerResponse
                    .status(HttpStatus.CONFLICT)
                    .bodyValue("Could not create airport2: " + e.getMessage()));
}
```

### Key Takeaways

1. When using Spring Data R2DBC with manually assigned IDs, be aware that the standard `save()` method will attempt to update rather than insert
2. For entities with natural keys or manually assigned IDs, implement custom insert methods using the `@Query` annotation
3. Reserve the standard `save()` method for update operations only
4. Consider adding existence checks before insert operations to provide better error handling
